<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>1</storyId>
    <title>Implement Natural Language Query Input</title>
    <status>drafted</status>
    <generatedAt>2025-12-03</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>C:\Users\fredr\Documents\KIProject\SG-KI-Krigerne\docs\sprint-artifacts\2-1-implement-natural-language-query-input.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>User</asA>
    <iWant>to ask questions about course information in natural language</iWant>
    <soThat>I can find information without needing to know specific commands or keywords</soThat>
    <tasks>
- [ ] **Task 1: Design and Implement FastAPI Endpoint for Natural Language Query (AC: 1, 2, 3)**
    - [ ] Subtask 1.1: Create a new file `backend/src/api/chat.py` to house the chat endpoint.
    - [ ] Subtask 1.2: Define a `POST /chat` endpoint in `backend/src/api/chat.py` that accepts a JSON payload with a `query` string (e.g., `{"query": "what is the exam format for TDT4140?"}`).
    - [ ] Subtask 1.3: Integrate the new `chat` router into `backend/main.py`.
    - [ ] Subtask 1.4: Implement a basic placeholder response for the endpoint (e.g., echoing the received query) to verify connectivity.
- [ ] **Task 2: Implement Intent and Entity Extraction Logic (AC: 4)**
    - [ ] Subtask 2.1: Create a new file `backend/src/rag/query_parser.py` for query parsing logic.
    - [ ] Subtask 2.2: Implement a function in `query_parser.py` that takes a natural language `query` string as input.
    - [ ] Subtask 2.3: Use simple keyword matching or regex to identify core intent (e.g., `get_exam_format`, `get_learning_outcomes`, `get_mandatory_assignments`) and extract relevant entities (e.g., `course_code: TDT4140`).
    - [ ] Subtask 2.4: Define a clear output structure for the parsed intent and entities (e.g., a Pydantic model).
    - [ ] Subtask 2.5: Integrate the `query_parser.py` into the `POST /chat` endpoint to process the incoming query.
- [ ] **Task 3: Write Backend Tests (Pytest)**
    - [ ] Subtask 3.1: Create a test file `backend/tests/test_chat_api.py`.
    - [ ] Subtask 3.2: Write a test for the `POST /chat` endpoint to ensure it receives a query and returns a placeholder response. (AC: 1, 2, 3)
    - [ ] Subtask 3.3: Create a test file `backend/tests/test_query_parser.py`.
    - [ ] Subtask 3.4: Write unit tests for `query_parser.py` to verify correct intent and entity extraction for various natural language queries. (AC: 4)
        - Test case: "what is the exam format for TDT4140?" -> intent: `get_exam_format`, entity: `course_code: TDT4140`
        - Test case: "learning outcomes for MAT100" -> intent: `get_learning_outcomes`, entity: `course_code: MAT100`
        - Test case: "mandatory assignments for LOG200" -> intent: `get_mandatory_assignments`, entity: `course_code: LOG200`
    </tasks>
  </story>

  <acceptanceCriteria>
    1.  **Given** the user has entered a question (e.g., "what is the exam format for TDT4140?"),
    2.  **When** they send the message,
    3.  **Then** the system backend receives the raw text of the question.
    4.  **And** the backend identifies the user's core intent (e.g., `get_exam_format`) and the key entity (e.g., `course_code: TDT4140`).
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/prd.md</path>
        <title>ibe160 - Product Requirements Document</title>
        <section>Functional Requirements</section>
        <snippet>FR1: The user can ask questions about course information in natural language.</snippet>
      </doc>
      <doc>
        <path>docs/prd.md</path>
        <title>ibe160 - Product Requirements Document</title>
        <section>Product Scope - MVP</section>
        <snippet>Natural Language Q&amp;A: The chatbot will be capable of understanding and responding to natural language queries regarding specific course information.</snippet>
      </doc>
      <doc>
        <path>docs/prd.md</path>
        <title>ibe160 - Product Requirements Document</title>
        <section>Innovation &amp; Novel Patterns</section>
        <snippet>The Himolde Study Friend introduces innovation through its AI-powered chatbot leveraging a Retrieval-Augmented Generation (RAG) architecture for accurate, natural language interaction with university course information.</snippet>
      </doc>
      <doc>
        <path>docs/prd.md</path>
        <title>ibe160 - Product Requirements Document</title>
        <section>Key Interactions</section>
        <snippet>Natural Language Query Input: Students type or speak their questions.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture</title>
        <section>Executive Summary</section>
        <snippet>The Himolde Study Friend project aims to centralize course information through an AI-powered chatbot, providing instant and accurate answers to student queries...The architecture will be kept simple with one backend service and a single knowledge base for Retrieval-Augmented Generation (RAG).</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture</title>
        <section>Decision Summary (Backend - API Pattern)</section>
        <snippet>Backend - API Pattern: REST is simple, well-understood, and sufficient for MVP; aligns with 'one backend service' and clarity goals.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture</title>
        <section>Decision Summary (AI - Application)</section>
        <snippet>AI - Application: Gemini API for LLM integration, PostgreSQL with pgvector for the vector database, and a lightweight custom RAG orchestration flow in the backend for simplicity and direct Gemini API interaction.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture</title>
        <section>Project Structure</section>
        <snippet>himolde-study-friend/├───backend/│   ├───src/│   ├───api/ (for API endpoints and logic) │   ├───rag/ (for RAG specific logic, Gemini API integration)</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture</title>
        <section>Epic to Architecture Mapping (Epic 2, Story 2.1)</section>
        <snippet>Epic 2: Core Question Answering, Story 2.1: Implement Natural Language Query Input → `frontend/src/components/`, `backend/src/api/`.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture</title>
        <section>Implementation Patterns (Backend - Python)</section>
        <snippet>Backend (Python): Variables/Functions: `snake_case`, Classes: `PascalCase`, Files/Modules: `snake_case`. Organize by type/domain (e.g., `api/` for endpoints, `services/` for business logic, `db/` for database interactions, `rag/` for RAG logic).</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture</title>
        <section>API Contracts (Main Chat Endpoint)</section>
        <snippet>Main Chat Endpoint (`POST /chat`): Streams responses using Server-Sent Events (SSE) / Streaming HTTP.</snippet>
      </doc>
      <doc>
        <path>docs/ux-design-specification.md</path>
        <title>ibe160 UX Design Specification</title>
        <section>2.1 Defining Experience</section>
        <snippet>The core experience of the Himolde Study Friend chatbot revolves around effortless natural language Q&amp;A. Users will primarily interact by typing questions such as 'Does MAT100 have mandatory assignments?' or 'What is the exam format for SCM130?' into a web browser interface.</snippet>
      </doc>
      <doc>
        <path>docs/ux-design-specification.md</path>
        <title>ibe160 UX Design Specification</title>
        <section>2.4 Inspiration Analysis</section>
        <snippet>Key UX Patterns to Adopt: Streamlined conversational interface; Rapid and clear responses; Emphasis on information reliability; Clean and uncluttered UI.</snippet>
      </doc>
      <doc>
        <path>docs/ux-design-specification.md</path>
        <title>ibe160 UX Design Specification</title>
        <section>5.1 Critical User Paths - Input (User types and sends question)</section>
        <snippet>Input (User types and sends question): User sees: The question being typed in the input field. User does: Types a natural-language question. Hits Enter or clicks 'Send'.</snippet>
      </doc>
      <doc>
        <path>docs/ux-design-specification.md</path>
        <title>ibe160 UX Design Specification</title>
        <section>7.1 Consistency Rules - Form Patterns (for Chat Input)</section>
        <snippet>Form Patterns (for Chat Input): No explicit labels are used for the main chat input field; placeholder text serves as the primary prompt.</snippet>
      </doc>
      <doc>
        <path>docs/ux-design-specification.md</path>
        <title>ibe160 UX Design Specification</title>
        <section>7.1 Consistency Rules - Search Patterns (Implicit in Chat)</section>
        <snippet>Search Patterns (Implicit in Chat): The primary search trigger is the user sending a message within the chat input field.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>ibe160 - Epic Breakdown</title>
        <section>FR Coverage Map - Epic 2: Core Question Answering</section>
        <snippet>Epic 2: Core Question Answering covers FR1: The user can ask questions about course information in natural language.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>ibe160 - Epic Breakdown</title>
        <section>Epic 2: Core Question Answering - Story 2.1: Implement Natural Language Query Input</section>
        <snippet>User Story: As a User, I want to ask questions about course information in natural language, So that I can find information without needing to know specific commands or keywords. Acceptance Criteria: Backend receives question, identifies intent and entity.</snippet>
      </doc>
    </docs>
    <code_artifacts>
      <code_artifact>
        <path>backend/main.py</path>
        <kind>main application</kind>
        <symbol>app</symbol>
        <reason>Main FastAPI application where the new chat router will be integrated.</reason>
      </code_artifact>
      <code_artifact>
        <path>backend/src/db/knowledge_base_manager.py</path>
        <kind>utility</kind>
        <symbol>create_knowledge_base_if_not_exists, load_knowledge_base</symbol>
        <reason>Manages the loading and creation of the knowledge base, which is crucial for the RAG pipeline.</reason>
      </code_artifact>
    </code_artifacts>
    <dependencies>
      <node>
        <package name="@radix-ui/react-scroll-area" version="^1.2.10"/>
        <package name="@radix-ui/react-slot" version="^1.2.4"/>
        <package name="class-variance-authority" version="^0.7.1"/>
        <package name="clsx" version="^2.1.1"/>
        <package name="lucide-react" version="^0.555.0"/>
        <package name="react" version="^19.2.0"/>
        <package name="react-dom" version="^19.2.0"/>
        <package name="tailwind-merge" version="^3.4.0"/>
        <package name="tailwindcss-animate" version="^1.0.7"/>
        <package name="vite" version="^7.2.4"/>
        <package name="typescript" version="~5.9.3"/>
        <package name="tailwindcss" version="^4.1.17"/>
        <package name="postcss" version="^8.5.6"/>
        <package name="autoprefixer" version="^10.4.22"/>
        <package name="eslint" version="^9.39.1"/>
        <package name="prettier" version="^3.7.3"/>
        <package name="vitest" version="^4.0.15"/>
      </node>
      <python>
        <package name="fastapi" version="==0.122.0"/>
        <package name="uvicorn" version="==0.27.0.post1"/>
        <package name="pydantic" version="==1.10.13"/>
        <package name="pytest" version="==8.0.0"/>
      </python>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>
      <description>Functional Requirements Covered: FR1.</description>
    </constraint>
    <constraint>
      <description>This story is the entry point for the RAG pipeline.</description>
    </constraint>
    <constraint>
      <description>The initial implementation for intent and entity extraction can use simple keyword matching or regex.</description>
    </constraint>
    <constraint>
      <description>Backend API pattern will be REST, expecting a JSON payload with the query.</description>
    </constraint>
    <constraint>
      <description>Naming Conventions (Backend Python): snake_case for variables/functions, PascalCase for classes, snake_case for files/modules.</description>
    </constraint>
    <constraint>
      <description>Code Organization (Backend): Organize by type/domain (e.g., api/ for endpoints, services/, db/, rag/).</description>
    </constraint>
    <constraint>
      <description>API Contracts: /chat streaming endpoint: SSE/HTTP with JSON chunks and final.</description>
    </constraint>
    <constraint>
      <description>AI safety via prompt instructions and avoiding logging full prompts/answers.</description>
    </constraint>
  </constraints>
  <interfaces>
    <interface>
      <name>POST /chat</name>
      <kind>REST endpoint</kind>
      <signature>Accepts a JSON payload with a `query` string (e.g., `{"query": "what is the exam format for TDT4140?"}`).</signature>
      <path>backend/src/api/chat.py</path>
    </interface>
  </interfaces>
  <tests>
    <standards>Testing for the backend will primarily use Pytest. Tests will verify FastAPI endpoint functionality and the correctness of natural language intent and entity extraction logic.</standards>
    <locations>
      <location>backend/tests/</location>
      <location>backend/tests/test_chat_api.py</location>
      <location>backend/tests/test_query_parser.py</location>
    </locations>
    <ideas>
      <idea ac_id="1, 2, 3">Verify `POST /chat` endpoint receives a query and returns a placeholder response.</idea>
      <idea ac_id="4">Write unit tests for `query_parser.py` to verify correct intent and entity extraction for various natural language queries, including: "what is the exam format for TDT4140?", "learning outcomes for MAT100", and "mandatory assignments for LOG200".</idea>
    </ideas>
  </tests>
</story-context>